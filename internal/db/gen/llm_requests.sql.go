// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: llm_requests.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLLMRequest = `-- name: CreateLLMRequest :one
INSERT INTO data.llm_requests (session_id, message_id, input_tokens, output_tokens, total_tokens, model)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, uuid, session_id, input_tokens, output_tokens, total_tokens, model, created_at, message_id
`

type CreateLLMRequestParams struct {
	SessionID    int64       `json:"session_id"`
	MessageID    pgtype.Int8 `json:"message_id"`
	InputTokens  int32       `json:"input_tokens"`
	OutputTokens int32       `json:"output_tokens"`
	TotalTokens  int32       `json:"total_tokens"`
	Model        string      `json:"model"`
}

// CreateLLMRequest
//
//	INSERT INTO data.llm_requests (session_id, message_id, input_tokens, output_tokens, total_tokens, model)
//	VALUES ($1, $2, $3, $4, $5, $6)
//	RETURNING id, uuid, session_id, input_tokens, output_tokens, total_tokens, model, created_at, message_id
func (q *Queries) CreateLLMRequest(ctx context.Context, arg CreateLLMRequestParams) (*DataLlmRequest, error) {
	row := q.db.QueryRow(ctx, createLLMRequest,
		arg.SessionID,
		arg.MessageID,
		arg.InputTokens,
		arg.OutputTokens,
		arg.TotalTokens,
		arg.Model,
	)
	var i DataLlmRequest
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.SessionID,
		&i.InputTokens,
		&i.OutputTokens,
		&i.TotalTokens,
		&i.Model,
		&i.CreatedAt,
		&i.MessageID,
	)
	return &i, err
}

const getSessionLLMRequests = `-- name: GetSessionLLMRequests :many
SELECT id, uuid, session_id, input_tokens, output_tokens, total_tokens, model, created_at, message_id FROM data.llm_requests
WHERE session_id = $1
ORDER BY created_at ASC
`

// GetSessionLLMRequests
//
//	SELECT id, uuid, session_id, input_tokens, output_tokens, total_tokens, model, created_at, message_id FROM data.llm_requests
//	WHERE session_id = $1
//	ORDER BY created_at ASC
func (q *Queries) GetSessionLLMRequests(ctx context.Context, sessionID int64) ([]*DataLlmRequest, error) {
	rows, err := q.db.Query(ctx, getSessionLLMRequests, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DataLlmRequest
	for rows.Next() {
		var i DataLlmRequest
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.SessionID,
			&i.InputTokens,
			&i.OutputTokens,
			&i.TotalTokens,
			&i.Model,
			&i.CreatedAt,
			&i.MessageID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionTokenUsage = `-- name: GetSessionTokenUsage :one
SELECT
    COALESCE(SUM(input_tokens), 0)::INT AS total_input_tokens,
    COALESCE(SUM(output_tokens), 0)::INT AS total_output_tokens,
    COALESCE(SUM(total_tokens), 0)::INT AS total_tokens,
    COUNT(*)::INT AS request_count
FROM data.llm_requests
WHERE session_id = $1
`

type GetSessionTokenUsageRow struct {
	TotalInputTokens  int32 `json:"total_input_tokens"`
	TotalOutputTokens int32 `json:"total_output_tokens"`
	TotalTokens       int32 `json:"total_tokens"`
	RequestCount      int32 `json:"request_count"`
}

// GetSessionTokenUsage
//
//	SELECT
//	    COALESCE(SUM(input_tokens), 0)::INT AS total_input_tokens,
//	    COALESCE(SUM(output_tokens), 0)::INT AS total_output_tokens,
//	    COALESCE(SUM(total_tokens), 0)::INT AS total_tokens,
//	    COUNT(*)::INT AS request_count
//	FROM data.llm_requests
//	WHERE session_id = $1
func (q *Queries) GetSessionTokenUsage(ctx context.Context, sessionID int64) (*GetSessionTokenUsageRow, error) {
	row := q.db.QueryRow(ctx, getSessionTokenUsage, sessionID)
	var i GetSessionTokenUsageRow
	err := row.Scan(
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalTokens,
		&i.RequestCount,
	)
	return &i, err
}

const getUserTokenUsage = `-- name: GetUserTokenUsage :one
SELECT
    COALESCE(SUM(lr.input_tokens), 0)::INT AS total_input_tokens,
    COALESCE(SUM(lr.output_tokens), 0)::INT AS total_output_tokens,
    COALESCE(SUM(lr.total_tokens), 0)::INT AS total_tokens,
    COUNT(*)::INT AS request_count
FROM data.llm_requests lr
JOIN data.sessions s ON lr.session_id = s.id
WHERE s.user_id = $1
`

type GetUserTokenUsageRow struct {
	TotalInputTokens  int32 `json:"total_input_tokens"`
	TotalOutputTokens int32 `json:"total_output_tokens"`
	TotalTokens       int32 `json:"total_tokens"`
	RequestCount      int32 `json:"request_count"`
}

// GetUserTokenUsage
//
//	SELECT
//	    COALESCE(SUM(lr.input_tokens), 0)::INT AS total_input_tokens,
//	    COALESCE(SUM(lr.output_tokens), 0)::INT AS total_output_tokens,
//	    COALESCE(SUM(lr.total_tokens), 0)::INT AS total_tokens,
//	    COUNT(*)::INT AS request_count
//	FROM data.llm_requests lr
//	JOIN data.sessions s ON lr.session_id = s.id
//	WHERE s.user_id = $1
func (q *Queries) GetUserTokenUsage(ctx context.Context, userID int64) (*GetUserTokenUsageRow, error) {
	row := q.db.QueryRow(ctx, getUserTokenUsage, userID)
	var i GetUserTokenUsageRow
	err := row.Scan(
		&i.TotalInputTokens,
		&i.TotalOutputTokens,
		&i.TotalTokens,
		&i.RequestCount,
	)
	return &i, err
}
